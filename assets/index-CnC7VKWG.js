import{z as ye,i as be,t as u,p as Pe,a as we,g as ve,b as pe,c as Ee,e as G,d as m,f as w,B as k,s as ce,h as V,j as he,k as _,l as q,m as H,w as Ie,n as xe,u as Le,o as j,q as X,r as Se,v as y,M as B,x as re,y as W,S as Ae,A as h,R as A,C as J,D as Fe,E as ie,T as ne}from"./index-48acJclb.js";import{Chain as ze,Common as $}from"./index-JHAnXxkx.js";class p{constructor(e){if(e.length!==20)throw new Error("Invalid address length");this.bytes=e}static zero(){return new p(ye(20))}static fromString(e){if(!be(e))throw new Error("Invalid address");return new p(u(e))}static fromPublicKey(e){if(!(e instanceof Uint8Array))throw new Error("Public key should be Uint8Array");const t=Pe(e);return new p(t)}static fromPrivateKey(e){if(!(e instanceof Uint8Array))throw new Error("Private key should be Uint8Array");const t=we(e);return new p(t)}static generate(e,t){if(typeof t!="bigint")throw new Error("Expected nonce to be a bigint");return new p(ve(e.bytes,pe(t)))}static generate2(e,t,r){if(!(t instanceof Uint8Array))throw new Error("Expected salt to be a Uint8Array");if(!(r instanceof Uint8Array))throw new Error("Expected initCode to be a Uint8Array");return new p(Ee(e.bytes,t,r))}equals(e){return G(this.bytes,e.bytes)}isZero(){return this.equals(p.zero())}isPrecompileOrSystemAddress(){const e=m(this.bytes),t=k,r=BigInt("0xffff");return e>=t&&e<=r}toString(){return w(this.bytes)}toBytes(){return new Uint8Array(this.bytes)}}function Ce(s,e,t){const r=ce.sign(s,e),i=r.toCompactRawBytes(),n=i.slice(0,32),o=i.slice(32,64),a=t===void 0?BigInt(r.recovery+27):BigInt(r.recovery+35)+BigInt(t)*V;return{r:n,s:o,v:a}}function Te(s,e){return s===k||s===q?s:e===void 0?s-H:s-(e*V+BigInt(35))}function ke(s){return s===k||s===q}const Ge=function(s,e,t,r,i){const n=he(_(t,32),_(r,32)),o=Te(e,i);if(!ke(o))throw new Error("Invalid signature v value");return ce.Signature.fromCompact(n).addRecoveryBit(Number(o)).recoverPublicKey(s).toRawBytes(!1).slice(1)},Be=Ie(xe),Me=32,Y=4096,N=32*Y,Ne=2,_e=N*Ne-1,Ue=Me*Y;function Oe(s,e){const t=new Uint8Array(e*N).fill(0);return t.set(s),t[s.byteLength]=128,t}function $e(s){const e=new Uint8Array(Ue);for(let t=0;t<Y;t++){const r=new Uint8Array(32);r.set(s.subarray(t*31,(t+1)*31),0),e.set(r,t*32)}return e}const Ve=s=>{const e=Le(s),t=e.byteLength;if(t===0)throw Error("invalid blob data");if(t>_e)throw Error("blob data is too large");const r=Math.ceil(t/N),i=Oe(e,r),n=[];for(let o=0;o<r;o++){const a=i.subarray(o*N,(o+1)*N),c=$e(a);n.push(c)}return n},He=(s,e)=>{const t=[];for(const r of e)t.push(s.blobToKzgCommitment(r));return t},Je=(s,e,t)=>e.map((i,n)=>s.computeBlobKzgProof(i,t[n])),de=(s,e)=>{const t=new Uint8Array(32);return t.set([e],0),t.set(Be(s).subarray(1),1),t},Re=s=>{const e=[];for(const t of s)e.push(de(t,1));return e},Ke=async(s,e)=>{const t=JSON.stringify({method:e.method,params:e.params,jsonrpc:"2.0",id:1}),r=await fetch(s,{headers:{"content-type":"application/json"},method:"POST",body:t});if(!r.ok)throw new Error(`JSONRpcError: ${JSON.stringify({method:e.method,status:r.status,message:await r.text().catch(()=>"Could not parse error message likely because of a network error")},null,2)}`);return(await r.json()).result},De=s=>{if(typeof s=="string")return s;if(typeof s=="object"&&s._getConnection!==void 0)return s._getConnection().url;throw new Error("Must provide valid provider URL or Web3Provider")};var E;(function(s){s[s.EIP155ReplayProtection=155]="EIP155ReplayProtection",s[s.EIP1559FeeMarket=1559]="EIP1559FeeMarket",s[s.EIP2718TypedTransaction=2718]="EIP2718TypedTransaction",s[s.EIP2930AccessLists=2930]="EIP2930AccessLists"})(E||(E={}));function je(s){if(s.length===0)return!0;const e=s[0];return!!Array.isArray(e)}function Xe(s){return!je(s)}var f;(function(s){s[s.Legacy=0]="Legacy",s[s.AccessListEIP2930=1]="AccessListEIP2930",s[s.FeeMarketEIP1559=2]="FeeMarketEIP1559",s[s.BlobEIP4844=3]="BlobEIP4844"})(f||(f={}));function Ze(s){return Number(m(u(s.type)))===f.Legacy}function qe(s){return Number(m(u(s.type)))===f.AccessListEIP2930}function We(s){return Number(m(u(s.type)))===f.FeeMarketEIP1559}function Ye(s){return Number(m(u(s.type)))===f.BlobEIP4844}function Qe(s,e){const t=s.param("vm","maxInitCodeSize");if(t&&BigInt(e)>t)throw new Error(`the initcode size of this transaction is too large: it is ${e} while the max is ${s.param("vm","maxInitCodeSize")}`)}class I{static getAccessListData(e){let t,r;if(Xe(e)){t=e;const i=[];for(let n=0;n<e.length;n++){const o=e[n],a=j(o.address),c=[];for(let g=0;g<o.storageKeys.length;g++)c.push(j(o.storageKeys[g]));i.push([a,c])}r=i}else{r=e??[];const i=[];for(let n=0;n<r.length;n++){const o=r[n],a=w(o[0]),c=[];for(let d=0;d<o[1].length;d++)c.push(w(o[1][d]));const g={address:a,storageKeys:c};i.push(g)}t=i}return{AccessListJSON:t,accessList:r}}static verifyAccessList(e){for(let t=0;t<e.length;t++){const r=e[t],i=r[0],n=r[1];if(r[2]!==void 0)throw new Error("Access list item cannot have 3 elements. It can only have an address, and an array of storage slots.");if(i.length!==20)throw new Error("Invalid EIP-2930 transaction: address length should be 20 bytes");for(let o=0;o<n.length;o++)if(n[o].length!==32)throw new Error("Invalid EIP-2930 transaction: storage slot length should be 32 bytes")}}static getAccessListJSON(e){const t=[];for(let r=0;r<e.length;r++){const i=e[r],n={address:w(_(i[0],20)),storageKeys:[]},o=i[1];for(let a=0;a<o.length;a++){const c=o[a];n.storageKeys.push(w(_(c,32)))}t.push(n)}return t}static getDataFeeEIP2930(e,t){const r=t.param("gasPrices","accessListStorageKeyCost"),i=t.param("gasPrices","accessListAddressCost");let n=0;for(let a=0;a<e.length;a++){const g=e[a][1];n+=g.length}return e.length*Number(i)+n*Number(r)}}function U(s){return j("0x"+s.toString(16).padStart(2,"0"))}class L{constructor(e,t){this.cache={hash:void 0,dataFee:void 0,senderPubKey:void 0},this.activeCapabilities=[],this.DEFAULT_CHAIN=ze.Mainnet;const{nonce:r,gasLimit:i,to:n,value:o,data:a,v:c,r:g,s:d,type:l}=e;this._type=Number(m(u(l))),this.txOptions=t;const b=u(n===""?"0x":n),v=u(c===""?"0x":c),P=u(g===""?"0x":g),M=u(d===""?"0x":d);this.nonce=m(u(r===""?"0x":r)),this.gasLimit=m(u(i===""?"0x":i)),this.to=b.length>0?new p(b):void 0,this.value=m(u(o===""?"0x":o)),this.data=u(a===""?"0x":a),this.v=v.length>0?m(v):void 0,this.r=P.length>0?m(P):void 0,this.s=M.length>0?m(M):void 0,this._validateCannotExceedMaxInteger({value:this.value,r:this.r,s:this.s}),this._validateCannotExceedMaxInteger({gasLimit:this.gasLimit},64),this._validateCannotExceedMaxInteger({nonce:this.nonce},64,!0);const O=this.to===void 0||this.to===null,le=t.allowUnlimitedInitCodeSize??!1,se=t.common??this._getCommon();O&&se.isActivatedEIP(3860)&&le===!1&&Qe(se,this.data.length)}get type(){return this._type}supports(e){return this.activeCapabilities.includes(e)}getValidationErrors(){const e=[];return this.isSigned()&&!this.verifySignature()&&e.push("Invalid Signature"),this.getBaseFee()>this.gasLimit&&e.push(`gasLimit is too low. given ${this.gasLimit}, need at least ${this.getBaseFee()}`),e}isValid(){return this.getValidationErrors().length===0}getBaseFee(){const e=this.common.param("gasPrices","tx");let t=this.getDataFee();if(e&&(t+=e),this.common.gteHardfork("homestead")&&this.toCreationAddress()){const r=this.common.param("gasPrices","txCreation");r&&(t+=r)}return t}getDataFee(){const e=this.common.param("gasPrices","txDataZero"),t=this.common.param("gasPrices","txDataNonZero");let r=k;for(let i=0;i<this.data.length;i++)this.data[i]===0?r+=e:r+=t;if((this.to===void 0||this.to===null)&&this.common.isActivatedEIP(3860)){const i=BigInt(Math.ceil(this.data.length/32)),n=this.common.param("gasPrices","initCodeWordCost")*i;r+=n}return r}toCreationAddress(){return this.to===void 0||this.to.bytes.length===0}isSigned(){const{v:e,r:t,s:r}=this;return!(e===void 0||t===void 0||r===void 0)}verifySignature(){try{const e=this.getSenderPublicKey();return X(e).length!==0}catch{return!1}}getSenderAddress(){return new p(Se(this.getSenderPublicKey()))}sign(e){if(e.length!==32){const g=this._errorMsg("Private key must be 32 bytes in length.");throw new Error(g)}let t=!1;this.type===f.Legacy&&this.common.gteHardfork("spuriousDragon")&&!this.supports(E.EIP155ReplayProtection)&&(this.activeCapabilities.push(E.EIP155ReplayProtection),t=!0);const r=this.getHashedMessageToSign(),i=this.common.customCrypto?.ecsign??Ce,{v:n,r:o,s:a}=i(r,e),c=this.addSignature(n,o,a,!0);if(t){const g=this.activeCapabilities.indexOf(E.EIP155ReplayProtection);g>-1&&this.activeCapabilities.splice(g,1)}return c}toJSON(){return{type:y(BigInt(this.type)),nonce:y(this.nonce),gasLimit:y(this.gasLimit),to:this.to!==void 0?this.to.toString():void 0,value:y(this.value),data:w(this.data),v:this.v!==void 0?y(this.v):void 0,r:this.r!==void 0?y(this.r):void 0,s:this.s!==void 0?y(this.s):void 0}}_getCommon(e,t){if(t!==void 0){const r=m(u(t));if(e){if(e.chainId()!==r){const i=this._errorMsg(`The chain ID does not match the chain ID of Common. Got: ${r}, expected: ${e.chainId}`);throw new Error(i)}return e.copy()}else return $.isSupportedChainId(r)?new $({chain:r}):$.custom({name:"custom-chain",networkId:r,chainId:r},{baseChain:this.DEFAULT_CHAIN})}else return e?.copy()??new $({chain:this.DEFAULT_CHAIN})}_validateCannotExceedMaxInteger(e,t=256,r=!1){for(const[i,n]of Object.entries(e))switch(t){case 64:if(r){if(n!==void 0&&n>=re){const o=this._errorMsg(`${i} cannot equal or exceed MAX_UINT64 (2^64-1), given ${n}`);throw new Error(o)}}else if(n!==void 0&&n>re){const o=this._errorMsg(`${i} cannot exceed MAX_UINT64 (2^64-1), given ${n}`);throw new Error(o)}break;case 256:if(r){if(n!==void 0&&n>=B){const o=this._errorMsg(`${i} cannot equal or exceed MAX_INTEGER (2^256-1), given ${n}`);throw new Error(o)}}else if(n!==void 0&&n>B){const o=this._errorMsg(`${i} cannot exceed MAX_INTEGER (2^256-1), given ${n}`);throw new Error(o)}break;default:{const o=this._errorMsg("unimplemented bits value");throw new Error(o)}}}static _validateNotArray(e){const t=["nonce","gasPrice","gasLimit","to","value","data","v","r","s","type","baseFee","maxFeePerGas","chainId"];for(const[r,i]of Object.entries(e))if(t.includes(r)&&Array.isArray(i))throw new Error(`${r} cannot be an array`)}_getSharedErrorPostfix(){let e="";try{e=this.isSigned()?w(this.hash()):"not available (unsigned)"}catch{e="error"}let t="";try{t=this.isSigned().toString()}catch{e="error"}let r="";try{r=this.common.hardfork()}catch{r="error"}let i=`tx type=${this.type} hash=${e} nonce=${this.nonce} value=${this.value} `;return i+=`signed=${t} hf=${r}`,i}}function ue(s,e){const t=s.maxPriorityFeePerGas,r=s.maxFeePerGas-e,n=(t<r?t:r)+e;return s.gasLimit*n+s.value}function me(s,e){if(e===void 0||e>s.maxFeePerGas)throw new Error("Tx cannot pay baseFee");const t=s.maxFeePerGas-e;return s.maxPriorityFeePerGas<t?s.maxPriorityFeePerGas:t}function F(s,e){return`${e} (${s.errorStr()})`}function ge(s,e){if(s.cache.dataFee&&s.cache.dataFee.hardfork===s.common.hardfork())return s.cache.dataFee.value;const t=L.prototype.getDataFee.bind(s)()+(e??0n);return Object.isFrozen(s)&&(s.cache.dataFee={value:t,hardfork:s.common.hardfork()}),t}function R(s){if(!s.isSigned()){const t=F(s,"Cannot call hash method if transaction is not signed");throw new Error(t)}const e=s.common.customCrypto.keccak256??W;return Object.isFrozen(s)?(s.cache.hash||(s.cache.hash=e(s.serialize())),s.cache.hash):e(s.serialize())}function K(s){const{s:e}=s;if(s.common.gteHardfork("homestead")&&e!==void 0&&e>Ae){const t=F(s,"Invalid Signature: s-values greater than secp256k1n/2 are considered invalid");throw new Error(t)}}function D(s){if(s.cache.senderPubKey!==void 0)return s.cache.senderPubKey;const e=s.getMessageToVerifySignature(),{v:t,r,s:i}=s;K(s);try{const o=(s.common.customCrypto.ecrecover??Ge)(e,t,h(r),h(i),s.supports(E.EIP155ReplayProtection)?s.common.chainId():void 0);return Object.isFrozen(s)&&(s.cache.senderPubKey=o),o}catch{const o=F(s,"Invalid Signature");throw new Error(o)}}function fe(s,e){if(e!==void 0&&e>s)throw new Error("Tx cannot pay baseFee");return e===void 0?s:s-e}function Q(s){return(s.common.customCrypto.keccak256??W)(s.getMessageToSign())}function T(s,e){return he(U(s.type),A.encode(e??s.raw()))}function ee(s){const{v:e}=s;if(e!==void 0&&e!==k&&e!==q){const t=F(s,"The y-parity of the transaction should either be 0 or 1");throw new Error(t)}}function te(s){return ge(s,BigInt(I.getDataFeeEIP2930(s.accessList,s.common)))}class z extends L{constructor(e,t={}){super({...e,type:f.FeeMarketEIP1559},t);const{chainId:r,accessList:i,maxFeePerGas:n,maxPriorityFeePerGas:o}=e;if(this.common=this._getCommon(t.common,r),this.chainId=this.common.chainId(),this.common.isActivatedEIP(1559)===!1)throw new Error("EIP-1559 not enabled on Common");this.activeCapabilities=this.activeCapabilities.concat([1559,2718,2930]);const a=I.getAccessListData(i??[]);if(this.accessList=a.accessList,this.AccessListJSON=a.AccessListJSON,I.verifyAccessList(this.accessList),this.maxFeePerGas=m(u(n===""?"0x":n)),this.maxPriorityFeePerGas=m(u(o===""?"0x":o)),this._validateCannotExceedMaxInteger({maxFeePerGas:this.maxFeePerGas,maxPriorityFeePerGas:this.maxPriorityFeePerGas}),L._validateNotArray(e),this.gasLimit*this.maxFeePerGas>B){const g=this._errorMsg("gasLimit * maxFeePerGas cannot exceed MAX_INTEGER (2^256-1)");throw new Error(g)}if(this.maxFeePerGas<this.maxPriorityFeePerGas){const g=this._errorMsg("maxFeePerGas cannot be less than maxPriorityFeePerGas (The total must be the larger of the two)");throw new Error(g)}ee(this),K(this),(t?.freeze??!0)&&Object.freeze(this)}static fromTxData(e,t={}){return new z(e,t)}static fromSerializedTx(e,t={}){if(G(e.subarray(0,1),U(f.FeeMarketEIP1559))===!1)throw new Error(`Invalid serialized tx input: not an EIP-1559 transaction (wrong tx type, expected: ${f.FeeMarketEIP1559}, received: ${w(e.subarray(0,1))}`);const r=A.decode(e.subarray(1));if(!Array.isArray(r))throw new Error("Invalid serialized tx input: must be array");return z.fromValuesArray(r,t)}static fromValuesArray(e,t={}){if(e.length!==9&&e.length!==12)throw new Error("Invalid EIP-1559 transaction. Only expecting 9 values (for unsigned tx) or 12 values (for signed tx).");const[r,i,n,o,a,c,g,d,l,b,v,P]=e;return this._validateNotArray({chainId:r,v:b}),J({nonce:i,maxPriorityFeePerGas:n,maxFeePerGas:o,gasLimit:a,value:g,v:b,r:v,s:P}),new z({chainId:m(r),nonce:i,maxPriorityFeePerGas:n,maxFeePerGas:o,gasLimit:a,to:c,value:g,data:d,accessList:l??[],v:b!==void 0?m(b):void 0,r:v,s:P},t)}getDataFee(){return te(this)}getEffectivePriorityFee(e){return me(this,e)}getUpfrontCost(e=k){return ue(this,e)}raw(){return[h(this.chainId),h(this.nonce),h(this.maxPriorityFeePerGas),h(this.maxFeePerGas),h(this.gasLimit),this.to!==void 0?this.to.bytes:new Uint8Array(0),h(this.value),this.data,this.accessList,this.v!==void 0?h(this.v):new Uint8Array(0),this.r!==void 0?h(this.r):new Uint8Array(0),this.s!==void 0?h(this.s):new Uint8Array(0)]}serialize(){return T(this)}getMessageToSign(){return T(this,this.raw().slice(0,9))}getHashedMessageToSign(){return Q(this)}hash(){return R(this)}getMessageToVerifySignature(){return this.getHashedMessageToSign()}getSenderPublicKey(){return D(this)}addSignature(e,t,r,i=!1){t=u(t),r=u(r);const n={...this.txOptions,common:this.common};return z.fromTxData({chainId:this.chainId,nonce:this.nonce,maxPriorityFeePerGas:this.maxPriorityFeePerGas,maxFeePerGas:this.maxFeePerGas,gasLimit:this.gasLimit,to:this.to,value:this.value,data:this.data,accessList:this.accessList,v:i?e-H:e,r:m(t),s:m(r)},n)}toJSON(){const e=I.getAccessListJSON(this.accessList);return{...super.toJSON(),chainId:y(this.chainId),maxPriorityFeePerGas:y(this.maxPriorityFeePerGas),maxFeePerGas:y(this.maxFeePerGas),accessList:e}}errorStr(){let e=this._getSharedErrorPostfix();return e+=` maxFeePerGas=${this.maxFeePerGas} maxPriorityFeePerGas=${this.maxPriorityFeePerGas}`,e}_errorMsg(e){return F(this,e)}}class C extends L{constructor(e,t={}){super({...e,type:f.AccessListEIP2930},t);const{chainId:r,accessList:i,gasPrice:n}=e;if(this.common=this._getCommon(t.common,r),this.chainId=this.common.chainId(),!this.common.isActivatedEIP(2930))throw new Error("EIP-2930 not enabled on Common");this.activeCapabilities=this.activeCapabilities.concat([2718,2930]);const o=I.getAccessListData(i??[]);if(this.accessList=o.accessList,this.AccessListJSON=o.AccessListJSON,I.verifyAccessList(this.accessList),this.gasPrice=m(u(n===""?"0x":n)),this._validateCannotExceedMaxInteger({gasPrice:this.gasPrice}),L._validateNotArray(e),this.gasPrice*this.gasLimit>B){const c=this._errorMsg("gasLimit * gasPrice cannot exceed MAX_INTEGER");throw new Error(c)}ee(this),K(this),(t?.freeze??!0)&&Object.freeze(this)}static fromTxData(e,t={}){return new C(e,t)}static fromSerializedTx(e,t={}){if(G(e.subarray(0,1),U(f.AccessListEIP2930))===!1)throw new Error(`Invalid serialized tx input: not an EIP-2930 transaction (wrong tx type, expected: ${f.AccessListEIP2930}, received: ${w(e.subarray(0,1))}`);const r=A.decode(Uint8Array.from(e.subarray(1)));if(!Array.isArray(r))throw new Error("Invalid serialized tx input: must be array");return C.fromValuesArray(r,t)}static fromValuesArray(e,t={}){if(e.length!==8&&e.length!==11)throw new Error("Invalid EIP-2930 transaction. Only expecting 8 values (for unsigned tx) or 11 values (for signed tx).");const[r,i,n,o,a,c,g,d,l,b,v]=e;this._validateNotArray({chainId:r,v:l}),J({nonce:i,gasPrice:n,gasLimit:o,value:c,v:l,r:b,s:v});const P=[];return new C({chainId:m(r),nonce:i,gasPrice:n,gasLimit:o,to:a,value:c,data:g,accessList:d??P,v:l!==void 0?m(l):void 0,r:b,s:v},t)}getEffectivePriorityFee(e){return fe(this.gasPrice,e)}getDataFee(){return te(this)}getUpfrontCost(){return this.gasLimit*this.gasPrice+this.value}raw(){return[h(this.chainId),h(this.nonce),h(this.gasPrice),h(this.gasLimit),this.to!==void 0?this.to.bytes:new Uint8Array(0),h(this.value),this.data,this.accessList,this.v!==void 0?h(this.v):new Uint8Array(0),this.r!==void 0?h(this.r):new Uint8Array(0),this.s!==void 0?h(this.s):new Uint8Array(0)]}serialize(){return T(this)}getMessageToSign(){return T(this,this.raw().slice(0,8))}getHashedMessageToSign(){return Q(this)}hash(){return R(this)}getMessageToVerifySignature(){return this.getHashedMessageToSign()}getSenderPublicKey(){return D(this)}addSignature(e,t,r,i=!1){t=u(t),r=u(r);const n={...this.txOptions,common:this.common};return C.fromTxData({chainId:this.chainId,nonce:this.nonce,gasPrice:this.gasPrice,gasLimit:this.gasLimit,to:this.to,value:this.value,data:this.data,accessList:this.accessList,v:i?e-H:e,r:m(t),s:m(r)},n)}toJSON(){const e=I.getAccessListJSON(this.accessList);return{...super.toJSON(),chainId:y(this.chainId),gasPrice:y(this.gasPrice),accessList:e}}errorStr(){let e=this._getSharedErrorPostfix();return e+=` gasPrice=${this.gasPrice} accessListCount=${this.accessList?.length??0}`,e}_errorMsg(e){return F(this,e)}}const oe=6,et=(s,e,t,r,i,n)=>{if(!(s.length===e.length&&e.length===t.length))throw new Error("Number of blobVersionedHashes, blobs, and commitments not all equal");if(s.length===0)throw new Error("Invalid transaction with empty blobs");let o;try{o=n.verifyBlobKzgProofBatch(e,t,r)}catch(a){throw new Error(`KZG verification of blobs fail with error=${a}`)}if(!o)throw new Error("KZG proof cannot be verified from blobs/commitments");for(let a=0;a<s.length;a++){const c=de(t[a],i);if(!G(c,s[a]))throw new Error(`commitment for blob at index ${a} does not match versionedHash`)}};class x extends L{constructor(e,t={}){super({...e,type:f.BlobEIP4844},t);const{chainId:r,accessList:i,maxFeePerGas:n,maxPriorityFeePerGas:o,maxFeePerBlobGas:a}=e;if(this.common=this._getCommon(t.common,r),this.chainId=this.common.chainId(),this.common.isActivatedEIP(1559)===!1)throw new Error("EIP-1559 not enabled on Common");if(this.common.isActivatedEIP(4844)===!1)throw new Error("EIP-4844 not enabled on Common");this.activeCapabilities=this.activeCapabilities.concat([1559,2718,2930]);const c=I.getAccessListData(i??[]);if(this.accessList=c.accessList,this.AccessListJSON=c.AccessListJSON,I.verifyAccessList(this.accessList),this.maxFeePerGas=m(u(n===""?"0x":n)),this.maxPriorityFeePerGas=m(u(o===""?"0x":o)),this._validateCannotExceedMaxInteger({maxFeePerGas:this.maxFeePerGas,maxPriorityFeePerGas:this.maxPriorityFeePerGas}),L._validateNotArray(e),this.gasLimit*this.maxFeePerGas>B){const d=this._errorMsg("gasLimit * maxFeePerGas cannot exceed MAX_INTEGER (2^256-1)");throw new Error(d)}if(this.maxFeePerGas<this.maxPriorityFeePerGas){const d=this._errorMsg("maxFeePerGas cannot be less than maxPriorityFeePerGas (The total must be the larger of the two)");throw new Error(d)}this.maxFeePerBlobGas=m(u((a??"")===""?"0x":a)),this.blobVersionedHashes=(e.blobVersionedHashes??[]).map(d=>u(d)),ee(this),K(this);for(const d of this.blobVersionedHashes){if(d.length!==32){const l=this._errorMsg("versioned hash is invalid length");throw new Error(l)}if(BigInt(d[0])!==this.common.param("sharding","blobCommitmentVersionKzg")){const l=this._errorMsg("versioned hash does not start with KZG commitment version");throw new Error(l)}}if(this.blobVersionedHashes.length>oe){const d=this._errorMsg(`tx can contain at most ${oe} blobs`);throw new Error(d)}else if(this.blobVersionedHashes.length===0){const d=this._errorMsg("tx should contain at least one blob");throw new Error(d)}if(this.to===void 0){const d=this._errorMsg('tx should have a "to" field and cannot be used to create contracts');throw new Error(d)}this.blobs=e.blobs?.map(d=>u(d)),this.kzgCommitments=e.kzgCommitments?.map(d=>u(d)),this.kzgProofs=e.kzgProofs?.map(d=>u(d)),(t?.freeze??!0)&&Object.freeze(this)}static fromTxData(e,t){if(t?.common?.customCrypto?.kzg===void 0)throw new Error("A common object with customCrypto.kzg initialized required to instantiate a 4844 blob tx");const r=t.common.customCrypto.kzg;if(e.blobsData!==void 0){if(e.blobs!==void 0)throw new Error("cannot have both raw blobs data and encoded blobs in constructor");if(e.kzgCommitments!==void 0)throw new Error("cannot have both raw blobs data and KZG commitments in constructor");if(e.blobVersionedHashes!==void 0)throw new Error("cannot have both raw blobs data and versioned hashes in constructor");if(e.kzgProofs!==void 0)throw new Error("cannot have both raw blobs data and KZG proofs in constructor");e.blobs=Ve(e.blobsData.reduce((i,n)=>i+n)),e.kzgCommitments=He(r,e.blobs),e.blobVersionedHashes=Re(e.kzgCommitments),e.kzgProofs=Je(r,e.blobs,e.kzgCommitments)}return new x(e,t)}getEffectivePriorityFee(e){return me(this,e)}static minimalFromNetworkWrapper(e,t){if(t?.common?.customCrypto?.kzg===void 0)throw new Error("A common object with customCrypto.kzg initialized required to instantiate a 4844 blob tx");return x.fromTxData({...e,blobs:void 0,kzgCommitments:void 0,kzgProofs:void 0},t)}static fromSerializedTx(e,t={}){if(t.common?.customCrypto?.kzg===void 0)throw new Error("A common object with customCrypto.kzg initialized required to instantiate a 4844 blob tx");if(G(e.subarray(0,1),U(f.BlobEIP4844))===!1)throw new Error(`Invalid serialized tx input: not an EIP-4844 transaction (wrong tx type, expected: ${f.BlobEIP4844}, received: ${w(e.subarray(0,1))}`);const r=A.decode(e.subarray(1));if(!Array.isArray(r))throw new Error("Invalid serialized tx input: must be array");return x.fromValuesArray(r,t)}static fromValuesArray(e,t={}){if(t.common?.customCrypto?.kzg===void 0)throw new Error("A common object with customCrypto.kzg initialized required to instantiate a 4844 blob tx");if(e.length!==11&&e.length!==14)throw new Error("Invalid EIP-4844 transaction. Only expecting 11 values (for unsigned tx) or 14 values (for signed tx).");const[r,i,n,o,a,c,g,d,l,b,v,P,M,O]=e;return this._validateNotArray({chainId:r,v:P}),J({nonce:i,maxPriorityFeePerGas:n,maxFeePerGas:o,gasLimit:a,value:g,maxFeePerBlobGas:b,v:P,r:M,s:O}),new x({chainId:m(r),nonce:i,maxPriorityFeePerGas:n,maxFeePerGas:o,gasLimit:a,to:c,value:g,data:d,accessList:l??[],maxFeePerBlobGas:b,blobVersionedHashes:v,v:P!==void 0?m(P):void 0,r:M,s:O},t)}static fromSerializedBlobTxNetworkWrapper(e,t){if(!t||!t.common)throw new Error("common instance required to validate versioned hashes");if(t.common?.customCrypto?.kzg===void 0)throw new Error("A common object with customCrypto.kzg initialized required to instantiate a 4844 blob tx");if(G(e.subarray(0,1),U(f.BlobEIP4844))===!1)throw new Error(`Invalid serialized tx input: not an EIP-4844 transaction (wrong tx type, expected: ${f.BlobEIP4844}, received: ${w(e.subarray(0,1))}`);const r=A.decode(e.subarray(1));if(r.length!==4)throw Error("Expected 4 values in the deserialized network transaction");const[i,n,o,a]=r,c=x.fromValuesArray(i,{...t,freeze:!1});if(c.to===void 0)throw Error("BlobEIP4844Transaction can not be send without a valid `to`");const g=Number(t.common.param("sharding","blobCommitmentVersionKzg"));return et(c.blobVersionedHashes,n,o,a,g,t.common.customCrypto.kzg),c.blobs=n,c.kzgCommitments=o,c.kzgProofs=a,(t?.freeze??!0)&&Object.freeze(c),c}getDataFee(){return te(this)}getUpfrontCost(e=k){return ue(this,e)}raw(){return[h(this.chainId),h(this.nonce),h(this.maxPriorityFeePerGas),h(this.maxFeePerGas),h(this.gasLimit),this.to!==void 0?this.to.bytes:new Uint8Array(0),h(this.value),this.data,this.accessList,h(this.maxFeePerBlobGas),this.blobVersionedHashes,this.v!==void 0?h(this.v):new Uint8Array(0),this.r!==void 0?h(this.r):new Uint8Array(0),this.s!==void 0?h(this.s):new Uint8Array(0)]}serialize(){return T(this)}serializeNetworkWrapper(){if(this.blobs===void 0||this.kzgCommitments===void 0||this.kzgProofs===void 0)throw new Error("cannot serialize network wrapper without blobs, KZG commitments and KZG proofs provided");return T(this,[this.raw(),this.blobs,this.kzgCommitments,this.kzgProofs])}getMessageToSign(){return T(this,this.raw().slice(0,11))}getHashedMessageToSign(){return Q(this)}hash(){return R(this)}getMessageToVerifySignature(){return this.getHashedMessageToSign()}getSenderPublicKey(){return D(this)}toJSON(){const e=I.getAccessListJSON(this.accessList);return{...super.toJSON(),chainId:y(this.chainId),maxPriorityFeePerGas:y(this.maxPriorityFeePerGas),maxFeePerGas:y(this.maxFeePerGas),accessList:e,maxFeePerBlobGas:y(this.maxFeePerBlobGas),blobVersionedHashes:this.blobVersionedHashes.map(r=>w(r))}}addSignature(e,t,r,i=!1){t=u(t),r=u(r);const n={...this.txOptions,common:this.common};return x.fromTxData({chainId:this.chainId,nonce:this.nonce,maxPriorityFeePerGas:this.maxPriorityFeePerGas,maxFeePerGas:this.maxFeePerGas,gasLimit:this.gasLimit,to:this.to,value:this.value,data:this.data,accessList:this.accessList,v:i?e-H:e,r:m(t),s:m(r),maxFeePerBlobGas:this.maxFeePerBlobGas,blobVersionedHashes:this.blobVersionedHashes,blobs:this.blobs,kzgCommitments:this.kzgCommitments,kzgProofs:this.kzgProofs},n)}errorStr(){let e=this._getSharedErrorPostfix();return e+=` maxFeePerGas=${this.maxFeePerGas} maxPriorityFeePerGas=${this.maxPriorityFeePerGas}`,e}_errorMsg(e){return F(this,e)}numBlobs(){return this.blobVersionedHashes.length}}function ae(s,e){const t=Number(s),r=Number(e)*2;return t===r+35||t===r+36}class S extends L{constructor(e,t={}){if(super({...e,type:f.Legacy},t),this.common=this._validateTxV(this.v,t.common),this.keccakFunction=this.common.customCrypto.keccak256??W,this.gasPrice=m(u(e.gasPrice===""?"0x":e.gasPrice)),this.gasPrice*this.gasLimit>B){const i=this._errorMsg("gas limit * gasPrice cannot exceed MAX_INTEGER (2^256-1)");throw new Error(i)}this._validateCannotExceedMaxInteger({gasPrice:this.gasPrice}),L._validateNotArray(e),this.common.gteHardfork("spuriousDragon")&&(this.isSigned()?ae(this.v,this.common.chainId())&&this.activeCapabilities.push(E.EIP155ReplayProtection):this.activeCapabilities.push(E.EIP155ReplayProtection)),(t?.freeze??!0)&&Object.freeze(this)}static fromTxData(e,t={}){return new S(e,t)}static fromSerializedTx(e,t={}){const r=A.decode(e);if(!Array.isArray(r))throw new Error("Invalid serialized tx input. Must be array");return this.fromValuesArray(r,t)}static fromValuesArray(e,t={}){if(e.length!==6&&e.length!==9)throw new Error("Invalid transaction. Only expecting 6 values (for unsigned tx) or 9 values (for signed tx).");const[r,i,n,o,a,c,g,d,l]=e;return J({nonce:r,gasPrice:i,gasLimit:n,value:a,v:g,r:d,s:l}),new S({nonce:r,gasPrice:i,gasLimit:n,to:o,value:a,data:c,v:g,r:d,s:l},t)}getEffectivePriorityFee(e){return fe(this.gasPrice,e)}raw(){return[h(this.nonce),h(this.gasPrice),h(this.gasLimit),this.to!==void 0?this.to.bytes:new Uint8Array(0),h(this.value),this.data,this.v!==void 0?h(this.v):new Uint8Array(0),this.r!==void 0?h(this.r):new Uint8Array(0),this.s!==void 0?h(this.s):new Uint8Array(0)]}serialize(){return A.encode(this.raw())}getMessageToSign(){const e=[h(this.nonce),h(this.gasPrice),h(this.gasLimit),this.to!==void 0?this.to.bytes:new Uint8Array(0),h(this.value),this.data];return this.supports(E.EIP155ReplayProtection)&&(e.push(h(this.common.chainId())),e.push(X(u(0))),e.push(X(u(0)))),e}getHashedMessageToSign(){const e=this.getMessageToSign();return this.keccakFunction(A.encode(e))}getDataFee(){return ge(this)}getUpfrontCost(){return this.gasLimit*this.gasPrice+this.value}hash(){return R(this)}getMessageToVerifySignature(){if(!this.isSigned()){const e=this._errorMsg("This transaction is not signed");throw new Error(e)}return this.getHashedMessageToSign()}getSenderPublicKey(){return D(this)}addSignature(e,t,r,i=!1){t=u(t),r=u(r),i&&this.supports(E.EIP155ReplayProtection)&&(e+=this.common.chainId()*V+Fe);const n={...this.txOptions,common:this.common};return S.fromTxData({nonce:this.nonce,gasPrice:this.gasPrice,gasLimit:this.gasLimit,to:this.to,value:this.value,data:this.data,v:e,r:m(t),s:m(r)},n)}toJSON(){return{...super.toJSON(),gasPrice:y(this.gasPrice)}}_validateTxV(e,t){let r;const i=e!==void 0?Number(e):void 0;if(i!==void 0&&i<37&&i!==27&&i!==28)throw new Error(`Legacy txs need either v = 27/28 or v >= 37 (EIP-155 replay protection), got v = ${i}`);if(i!==void 0&&i!==0&&(!t||t.gteHardfork("spuriousDragon"))&&i!==27&&i!==28)if(t){if(!ae(BigInt(i),t.chainId()))throw new Error(`Incompatible EIP155-based V ${i} and chain id ${t.chainId()}. See the Common parameter of the Transaction constructor to set the chain id.`)}else{let n;(i-35)%2===0?n=35:n=36,r=BigInt(i-n)/V}return this._getCommon(t,r)}errorStr(){let e=this._getSharedErrorPostfix();return e+=` gasPrice=${this.gasPrice}`,e}_errorMsg(e){return F(this,e)}}const tt=s=>{const e=Object.assign({},s);return e.gasLimit=ie(e.gasLimit??e.gas,ne.BigInt),e.data=e.data===void 0?e.input:e.data,e.gasPrice=e.gasPrice!==void 0?BigInt(e.gasPrice):void 0,e.value=e.value!==void 0?BigInt(e.value):void 0,e.to=e.to!==null&&e.to!==void 0?_(u(e.to),20):null,e.v=e.v==="0x0"?"0x":e.v,e.r=e.r==="0x0"?"0x":e.r,e.s=e.s==="0x0"?"0x":e.s,(e.v!=="0x"||e.r!=="0x"||e.s!=="0x")&&(e.v=ie(e.v,ne.BigInt)),e};class Z{constructor(){}static fromTxData(e,t={}){if(!("type"in e)||e.type===void 0)return S.fromTxData(e,t);if(Ze(e))return S.fromTxData(e,t);if(qe(e))return C.fromTxData(e,t);if(We(e))return z.fromTxData(e,t);if(Ye(e))return x.fromTxData(e,t);throw new Error(`Tx instantiation with type ${e?.type} not supported`)}static fromSerializedData(e,t={}){if(e[0]<=127)switch(e[0]){case f.AccessListEIP2930:return C.fromSerializedTx(e,t);case f.FeeMarketEIP1559:return z.fromSerializedTx(e,t);case f.BlobEIP4844:return x.fromSerializedTx(e,t);default:throw new Error(`TypedTransaction with ID ${e[0]} unknown`)}else return S.fromSerializedTx(e,t)}static fromBlockBodyData(e,t={}){if(e instanceof Uint8Array)return this.fromSerializedData(e,t);if(Array.isArray(e))return S.fromValuesArray(e,t);throw new Error("Cannot decode transaction: unknown type input")}static async fromJsonRpcProvider(e,t,r){const i=De(e),n=await Ke(i,{method:"eth_getTransactionByHash",params:[t]});if(n===null)throw new Error("No data returned from provider");return Z.fromRPC(n,r)}static async fromRPC(e,t={}){return Z.fromTxData(tt(e),t)}}export{C as AccessListEIP2930Transaction,x as BlobEIP4844Transaction,E as Capability,z as FeeMarketEIP1559Transaction,S as LegacyTransaction,Z as TransactionFactory,f as TransactionType,Xe as isAccessList,je as isAccessListBytes,qe as isAccessListEIP2930TxData,Ye as isBlobEIP4844TxData,We as isFeeMarketEIP1559TxData,Ze as isLegacyTxData};
